Projeto de Redução de Dimensionalidade em Imagens
Vou implementar um programa em Python para converter uma imagem colorida em níveis de cinza e depois binarizá-la (preto e branco). Vou usar a biblioteca OpenCV para processamento de imagens.

python
import cv2
import numpy as np
import matplotlib.pyplot as plt

def converter_para_cinza(imagem_colorida):
    """
    Converte uma imagem colorida para níveis de cinza.
    
    Parâmetros:
    imagem_colorida: imagem no formato BGR (padrão OpenCV)
    
    Retorna:
    Imagem em níveis de cinza (0-255)
    """
    # Converter BGR para escala de cinza usando a fórmula padrão
    # Luminosidade = 0.299*R + 0.587*G + 0.114*B
    altura, largura, canais = imagem_colorida.shape
    
    # Criar matriz vazia para a imagem em cinza
    imagem_cinza = np.zeros((altura, largura), dtype=np.uint8)
    
    # Percorrer todos os pixels
    for i in range(altura):
        for j in range(largura):
            # Obter valores BGR
            b = imagem_colorida[i, j, 0]
            g = imagem_colorida[i, j, 1]
            r = imagem_colorida[i, j, 2]
            
            # Calcular valor de cinza usando a fórmula de luminosidade
            cinza = int(0.299 * r + 0.587 * g + 0.114 * b)
            
            # Garantir que o valor está no intervalo 0-255
            imagem_cinza[i, j] = min(255, max(0, cinza))
    
    return imagem_cinza

def binarizar_imagem(imagem_cinza, limiar=128):
    """
    Converte uma imagem em níveis de cinza para binária (preto e branco).
    
    Parâmetros:
    imagem_cinza: imagem em níveis de cinza
    limiar: valor de corte para binarização (padrão=128)
    
    Retorna:
    Imagem binarizada (0 ou 255)
    """
    altura, largura = imagem_cinza.shape
    
    # Criar matriz vazia para a imagem binarizada
    imagem_binaria = np.zeros((altura, largura), dtype=np.uint8)
    
    # Percorrer todos os pixels
    for i in range(altura):
        for j in range(largura):
            # Se o pixel for maior que o limiar, branco (255), caso contrário, preto (0)
            if imagem_cinza[i, j] > limiar:
                imagem_binaria[i, j] = 255
            else:
                imagem_binaria[i, j] = 0
    
    return imagem_binaria

def binarizar_com_opencv(imagem_cinza, limiar=128):
    """
    Versão alternativa usando OpenCV para binarização.
    Esta função é mais eficiente que a implementação manual.
    """
    # Aplicar limiarização (thresholding)
    _, imagem_binaria = cv2.threshold(imagem_cinza, limiar, 255, cv2.THRESH_BINARY)
    
    return imagem_binaria

def carregar_e_processar_imagem(caminho_imagem, limiar=128):
    """
    Carrega uma imagem e processa todas as conversões.
    
    Parâmetros:
    caminho_imagem: caminho para a imagem
    limiar: valor de corte para binarização
    
    Retorna:
    Dicionário com as imagens processadas
    """
    # Carregar imagem colorida
    imagem_colorida = cv2.imread(caminho_imagem)
    
    if imagem_colorida is None:
        print(f"Erro: Não foi possível carregar a imagem em {caminho_imagem}")
        return None
    
    # Converter BGR para RGB para visualização com matplotlib
    imagem_colorida_rgb = cv2.cvtColor(imagem_colorida, cv2.COLOR_BGR2RGB)
    
    # Converter para cinza (implementação manual)
    imagem_cinza = converter_para_cinza(imagem_colorida)
    
    # Binarizar (implementação manual)
    imagem_binaria = binarizar_imagem(imagem_cinza, limiar)
    
    # Usando funções OpenCV para comparação (opcional)
    imagem_cinza_cv2 = cv2.cvtColor(imagem_colorida, cv2.COLOR_BGR2GRAY)
    imagem_binaria_cv2 = binarizar_com_opencv(imagem_cinza_cv2, limiar)
    
    return {
        'colorida': imagem_colorida_rgb,
        'cinza': imagem_cinza,
        'binaria': imagem_binaria,
        'cinza_cv2': imagem_cinza_cv2,
        'binaria_cv2': imagem_binaria_cv2
    }

def exibir_resultados(resultados, titulo="Resultados do Processamento"):
    """
    Exibe as imagens processadas em uma grade.
    """
    fig, axes = plt.subplots(2, 3, figsize=(15, 10))
    
    # Configurar título principal
    fig.suptitle(titulo, fontsize=16, fontweight='bold')
    
    # Imagem colorida
    axes[0, 0].imshow(resultados['colorida'])
    axes[0, 0].set_title('Imagem Colorida (RGB)')
    axes[0, 0].axis('off')
    
    # Imagem em cinza (nossa implementação)
    axes[0, 1].imshow(resultados['cinza'], cmap='gray')
    axes[0, 1].set_title('Cinza (Nossa Implementação)')
    axes[0, 1].axis('off')
    
    # Imagem binária (nossa implementação)
    axes[0, 2].imshow(resultados['binaria'], cmap='gray')
    axes[0, 2].set_title('Binária (Nossa Implementação)')
    axes[0, 2].axis('off')
    
    # Espaço vazio
    axes[1, 0].axis('off')
    
    # Imagem em cinza (OpenCV)
    axes[1, 1].imshow(resultados['cinza_cv2'], cmap='gray')
    axes[1, 1].set_title('Cinza (OpenCV)')
    axes[1, 1].axis('off')
    
    # Imagem binária (OpenCV)
    axes[1, 2].imshow(resultados['binaria_cv2'], cmap='gray')
    axes[1, 2].set_title('Binária (OpenCV)')
    axes[1, 2].axis('off')
    
    plt.tight_layout()
    plt.show()

def analisar_dimensionalidade(imagens):
    """
    Analisa e compara a dimensionalidade das imagens.
    """
    print("=== ANÁLISE DE DIMENSIONALIDADE ===")
    
    # Para a imagem colorida
    altura, largura, canais = imagens['colorida'].shape
    print(f"Imagem Colorida:")
    print(f"  Dimensões: {altura} x {largura} x {canais}")
    print(f"  Número total de valores: {altura * largura * canais}")
    
    # Para a imagem em cinza
    altura_c, largura_c = imagens['cinza'].shape
    print(f"\nImagem em Cinza:")
    print(f"  Dimensões: {altura_c} x {largura_c}")
    print(f"  Número total de valores: {altura_c * largura_c}")
    
    # Calcular redução de dimensionalidade
    reducao = (1 - (altura_c * largura_c) / (altura * largura * canais)) * 100
    print(f"  Redução de dimensionalidade: {reducao:.2f}%")
    
    # Para a imagem binária
    altura_b, largura_b = imagens['binaria'].shape
    print(f"\nImagem Binária:")
    print(f"  Dimensões: {altura_b} x {largura_b}")
    print(f"  Número total de valores: {altura_b * largura_b}")
    
    # Cada pixel binário requer apenas 1 bit, então podemos calcular a redução em bits
    bits_colorida = altura * largura * canais * 8  # 8 bits por canal
    bits_binaria = altura_b * largura_b  # 1 bit por pixel
    reducao_bits = (1 - bits_binaria / bits_colorida) * 100
    print(f"  Redução em bits: {reducao_bits:.2f}%")
    
    print(f"\nComparação de tamanhos:")
    print(f"  Colorida: {altura * largura * canais} valores")
    print(f"  Cinza: {altura_c * largura_c} valores (1/3 do tamanho da colorida)")
    print(f"  Binária: {altura_b * largura_b} valores (1/24 do tamanho em bits)")

# Função principal
def main():
    # Verificar se o OpenCV está instalado
    print("Iniciando processamento de imagens...")
    print("OpenCV versão:", cv2.__version__)
    
    # Tentar carregar uma imagem de exemplo
    # Primeiro, vamos tentar usar a imagem Lena clássica
    # Se não estiver disponível localmente, criaremos uma imagem de exemplo
    
    caminhos_tentados = [
        'lena.jpg',
        'lena.png',
        'lena_color.jpg',
        'exemplo.jpg',
        'imagem.jpg'
    ]
    
    imagem_carregada = None
    caminho_imagem = None
    
    for caminho in caminhos_tentados:
        try:
            # Tentar carregar a imagem
            temp_imagem = cv2.imread(caminho)
            if temp_imagem is not None:
                imagem_carregada = temp_imagem
                caminho_imagem = caminho
                print(f"Imagem carregada: {caminho}")
                break
        except:
            continue
    
    # Se não encontrou nenhuma imagem, criar uma de exemplo
    if imagem_carregada is None:
        print("Nenhuma imagem encontrada. Criando imagem de exemplo...")
        
        # Criar uma imagem colorida de exemplo (gradiente)
        altura, largura = 256, 256
        imagem_exemplo = np.zeros((altura, largura, 3), dtype=np.uint8)
        
        for i in range(altura):
            for j in range(largura):
                # Criar gradientes de cor
                imagem_exemplo[i, j, 0] = j  # Canal B (azul) - varia horizontalmente
                imagem_exemplo[i, j, 1] = i  # Canal G (verde) - varia verticalmente
                imagem_exemplo[i, j, 2] = (i + j) // 2  # Canal R (vermelho)
        
        # Salvar imagem de exemplo temporariamente
        caminho_imagem = 'imagem_exemplo.jpg'
        cv2.imwrite(caminho_imagem, imagem_exemplo)
        print(f"Imagem de exemplo criada: {caminho_imagem}")
    
    # Processar a imagem
    limiar = 128  # Valor de limiar para binarização
    resultados = carregar_e_processar_imagem(caminho_imagem, limiar)
    
    if resultados is not None:
        # Exibir resultados
        exibir_resultados(resultados, "Conversão: Colorida → Cinza → Binária")
        
        # Analisar dimensionalidade
        analisar_dimensionalidade(resultados)
        
        # Mostrar histogramas para análise
        fig, axes = plt.subplots(1, 3, figsize=(15, 4))
        
        # Histograma da imagem em cinza
        axes[0].hist(resultados['cinza'].ravel(), bins=256, range=[0, 256], color='gray')
        axes[0].axvline(x=limiar, color='red', linestyle='--', label=f'Limiar={limiar}')
        axes[0].set_title('Histograma - Imagem em Cinza')
        axes[0].set_xlabel('Intensidade')
        axes[0].set_ylabel('Frequência')
        axes[0].legend()
        axes[0].grid(True, alpha=0.3)
        
        # Histograma da imagem em cinza (OpenCV)
        axes[1].hist(resultados['cinza_cv2'].ravel(), bins=256, range=[0, 256], color='blue', alpha=0.5)
        axes[1].hist(resultados['cinza'].ravel(), bins=256, range=[0, 256], color='gray', alpha=0.5)
        axes[1].axvline(x=limiar, color='red', linestyle='--', label=f'Limiar={limiar}')
        axes[1].set_title('Comparação de Histogramas')
        axes[1].set_xlabel('Intensidade')
        axes[1].set_ylabel('Frequência')
        axes[1].legend(['OpenCV', 'Nossa implementação', f'Limiar={limiar}'])
        axes[1].grid(True, alpha=0.3)
        
        # Histograma da imagem binária
        axes[2].hist(resultados['binaria'].ravel(), bins=2, range=[0, 256], color='black', rwidth=0.8)
        axes[2].set_title('Histograma - Imagem Binária')
        axes[2].set_xlabel('Valor (0 ou 255)')
        axes[2].set_ylabel('Frequência')
        axes[2].set_xticks([0, 255])
        axes[2].set_xticklabels(['Preto (0)', 'Branco (255)'])
        axes[2].grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()
        
        print("\n=== RESUMO ===")
        print("1. Conversão para cinza: Reduz de 3 canais (R, G, B) para 1 canal de intensidade.")
        print("2. Binarização: Reduz de 256 níveis de cinza para apenas 2 valores (0 e 255).")
        print("3. A redução de dimensionalidade simplifica a imagem, facilitando análise e processamento.")
        
        # Testar com diferentes limiares
        print("\n=== TESTE COM DIFERENTES LIMIARES ===")
        limiares_teste = [64, 128, 192]
        
        fig, axes = plt.subplots(1, len(limiares_teste), figsize=(15, 5))
        
        for idx, limiar_teste in enumerate(limiares_teste):
            # Binarizar com o limiar atual
            imagem_bin_teste = binarizar_imagem(resultados['cinza'], limiar_teste)
            
            # Exibir resultado
            axes[idx].imshow(imagem_bin_teste, cmap='gray')
            axes[idx].set_title(f'Binarização com limiar={limiar_teste}')
            axes[idx].axis('off')
        
        plt.suptitle('Efeito do Limiar na Binarização', fontsize=14, fontweight='bold')
        plt.tight_layout()
        plt.show()

if __name__ == "__main__":
    main()
Explicação do Código
O programa implementa as seguintes funcionalidades:

1. Conversão para Tons de Cinza
converter_para_cinza(): Converte uma imagem colorida (BGR) para tons de cinza usando a fórmula de luminosidade: 0.299*R + 0.587*G + 0.114*B

A imagem resultante tem valores de 0 a 255

2. Binarização
binarizar_imagem(): Converte uma imagem em tons de cinza para preto e branco (0 ou 255) usando um limiar

Pixels com valor acima do limiar tornam-se branco (255), os demais tornam-se preto (0)

3. Análise de Dimensionalidade
O programa mostra a redução de dimensionalidade:

Imagem colorida: 3 canais (R, G, B) × 8 bits cada = 24 bits por pixel

Imagem em cinza: 1 canal × 8 bits = 8 bits por pixel (redução de 66%)

Imagem binária: 1 bit por pixel (redução de 96% em relação à colorida)

4. Visualização
Exibe todas as versões da imagem (colorida, cinza, binária)

Mostra histogramas para análise das intensidades

Testa diferentes valores de limiar para binarização

Como Executar
Instale as dependências:

bash
pip install opencv-python numpy matplotlib
Execute o programa:

python
python nome_do_arquivo.py
Se você tiver uma imagem chamada "lena.jpg" no diretório, o programa a usará. Caso contrário, criará uma imagem de exemplo.

Resultados Esperados
Imagem Colorida: Original em RGB

Imagem em Tons de Cinza: Versão com 256 níveis de cinza

Imagem Binária: Versão preto e branco (apenas 2 valores)

Análise de Dimensionalidade: Comparação do tamanho dos dados em cada formato

Histogramas: Distribuição das intensidades de pixel

Teste com Limiares: Como diferentes valores de limiar afetam a binarização

Este projeto demonstra efetivamente a redução de dimensionalidade em imagens, indo de uma representação colorida complexa (3 canais) para uma representação simplificada binária (1 bit por pixel).

